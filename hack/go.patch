From a6b4de9b3c325e14dc62aa55b6a0f5873ea06b99 Mon Sep 17 00:00:00 2001
From: Thanatat Tamtan <acoshift@gmail.com>
Date: Sun, 28 May 2023 00:03:14 +0700
Subject: [PATCH] patch

---
 src/net/http/h2_bundle.go             |  7 ++-
 src/net/http/header.go                | 25 +++++++++-
 src/net/http/httputil/reverseproxy.go | 68 ++++++++++++++++++---------
 src/net/http/request.go               | 31 ++++++++++--
 src/net/http/server.go                |  7 ++-
 src/net/textproto/reader.go           | 33 ++++++++++++-
 6 files changed, 140 insertions(+), 31 deletions(-)

diff --git a/src/net/http/h2_bundle.go b/src/net/http/h2_bundle.go
index 1e0b83d493..139038a606 100644
--- a/src/net/http/h2_bundle.go
+++ b/src/net/http/h2_bundle.go
@@ -5989,7 +5989,8 @@ func (sc *http2serverConn) newWriterAndRequestNoBody(st *http2stream, rp http2re
 		stream:        st,
 		needsContinue: needsContinue,
 	}
-	req := &Request{
+	req := newRequest()
+	*req = Request{
 		Method:     rp.method,
 		URL:        url_,
 		RemoteAddr: sc.remoteAddrStr,
@@ -6003,7 +6004,7 @@ func (sc *http2serverConn) newWriterAndRequestNoBody(st *http2stream, rp http2re
 		Body:       body,
 		Trailer:    trailer,
 	}
-	req = req.WithContext(st.ctx)
+	setRequestContext(req, st.ctx)

 	rw := sc.newResponseWriter(st, req)
 	return rw, req, nil
@@ -6696,6 +6697,8 @@ func (w *http2responseWriter) handlerDone() {
 	w.Flush()
 	w.rws = nil
 	if !dirty {
+		putRequest(rws.req)
+		rws.req = nil
 		// Only recycle the pool if all prior Write calls to
 		// the serverConn goroutine completed successfully. If
 		// they returned earlier due to resets from the peer
diff --git a/src/net/http/header.go b/src/net/http/header.go
index e0b342c63c..44dba75b79 100644
--- a/src/net/http/header.go
+++ b/src/net/http/header.go
@@ -102,7 +102,7 @@ func (h Header) Clone() Header {
 		nv += len(vv)
 	}
 	sv := make([]string, nv) // shared backing array for headers' values
-	h2 := make(Header, len(h))
+	var h2 Header = newHeader(len(h))
 	for k, vv := range h {
 		if vv == nil {
 			// Preserve nil values. ReverseProxy distinguishes
@@ -278,3 +278,26 @@ func hasToken(v, token string) bool {
 func isTokenBoundary(b byte) bool {
 	return b == ' ' || b == ',' || b == '\t'
 }
+
+var headerPool sync.Pool
+
+func newHeader(hint int) map[string][]string {
+	if hint <= maxHeaderCapReuse {
+		if v := headerPool.Get(); v != nil {
+			return v.(map[string][]string)
+		}
+	}
+	return make(map[string][]string, hint)
+}
+
+const maxHeaderCapReuse = 50
+
+func putHeader(h map[string][]string) {
+	if h == nil || len(h) > maxHeaderCapReuse { // should be cap ?
+		return
+	}
+	for k := range h {
+		delete(h, k)
+	}
+	headerPool.Put(h)
+}
diff --git a/src/net/http/httputil/reverseproxy.go b/src/net/http/httputil/reverseproxy.go
index 58064a5332..d7cfb9ade8 100644
--- a/src/net/http/httputil/reverseproxy.go
+++ b/src/net/http/httputil/reverseproxy.go
@@ -22,6 +22,7 @@ import (
 	"strings"
 	"sync"
 	"time"
+	_ "unsafe"

 	"golang.org/x/net/http/httpguts"
 )
@@ -280,9 +281,7 @@ func rewriteRequestURL(req *http.Request, target *url.URL) {

 func copyHeader(dst, src http.Header) {
 	for k, vv := range src {
-		for _, v := range vv {
-			dst.Add(k, v)
-		}
+		dst[k] = append([]string(nil), vv...)
 	}
 }

@@ -362,6 +361,7 @@ func (p *ReverseProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
 	}

 	outreq := req.Clone(ctx)
+	defer putRequest(outreq)
 	if req.ContentLength == 0 {
 		outreq.Body = nil // Issue 16036: nil Body for http.Transport retries
 	}
@@ -404,24 +404,24 @@ func (p *ReverseProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
 	// mentioning.) Note that we look at req.Header, not outreq.Header, since
 	// the latter has passed through removeHopByHopHeaders.
 	if httpguts.HeaderValuesContainsToken(req.Header["Te"], "trailers") {
-		outreq.Header.Set("Te", "trailers")
+		outreq.Header["Te"] = []string{"trailers"}
 	}

 	// After stripping all the hop-by-hop connection headers above, add back any
 	// necessary for protocol upgrades, such as for websockets.
 	if reqUpType != "" {
-		outreq.Header.Set("Connection", "Upgrade")
-		outreq.Header.Set("Upgrade", reqUpType)
+		outreq.Header["Connection"] = []string{"Upgrade"}
+		outreq.Header["Upgrade"] = []string{reqUpType}
 	}

 	if p.Rewrite != nil {
 		// Strip client-provided forwarding headers.
 		// The Rewrite func may use SetXForwarded to set new values
 		// for these or copy the previous values from the inbound request.
-		outreq.Header.Del("Forwarded")
-		outreq.Header.Del("X-Forwarded-For")
-		outreq.Header.Del("X-Forwarded-Host")
-		outreq.Header.Del("X-Forwarded-Proto")
+		delete(outreq.Header, "Forwarded")
+		delete(outreq.Header, "X-Forwarded-For")
+		delete(outreq.Header, "X-Forwarded-Host")
+		delete(outreq.Header, "X-Forwarded-Proto")

 		// Remove unparsable query parameters from the outbound request.
 		outreq.URL.RawQuery = cleanQueryParams(outreq.URL.RawQuery)
@@ -443,7 +443,7 @@ func (p *ReverseProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
 				clientIP = strings.Join(prior, ", ") + ", " + clientIP
 			}
 			if !omit {
-				outreq.Header.Set("X-Forwarded-For", clientIP)
+				outreq.Header["X-Forwarded-For"] = []string{clientIP}
 			}
 		}
 	}
@@ -451,7 +451,7 @@ func (p *ReverseProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
 	if _, ok := outreq.Header["User-Agent"]; !ok {
 		// If the outbound request doesn't have a User-Agent header set,
 		// don't send the default Go HTTP client User-Agent.
-		outreq.Header.Set("User-Agent", "")
+		outreq.Header["User-Agent"] = []string{""}
 	}

 	trace := &httptrace.ClientTrace{
@@ -468,7 +468,7 @@ func (p *ReverseProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
 			return nil
 		},
 	}
-	outreq = outreq.WithContext(httptrace.WithClientTrace(outreq.Context(), trace))
+	setRequestContext(outreq, httptrace.WithClientTrace(outreq.Context(), trace))

 	res, err := transport.RoundTrip(outreq)
 	if err != nil {
@@ -501,7 +501,7 @@ func (p *ReverseProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
 		for k := range res.Trailer {
 			trailerKeys = append(trailerKeys, k)
 		}
-		rw.Header().Add("Trailer", strings.Join(trailerKeys, ", "))
+		rw.Header()["Trailer"] = append(rw.Header()["Trailer"], strings.Join(trailerKeys, ", "))
 	}

 	rw.WriteHeader(res.StatusCode)
@@ -536,9 +536,7 @@ func (p *ReverseProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {

 	for k, vv := range res.Trailer {
 		k = http.TrailerPrefix + k
-		for _, v := range vv {
-			rw.Header().Add(k, v)
-		}
+		rw.Header()[k] = append(rw.Header()[k], vv...)
 	}
 }

@@ -578,7 +576,7 @@ func removeHopByHopHeaders(h http.Header) {
 	// This behavior is superseded by the RFC 7230 Connection header, but
 	// preserve it for backwards compatibility.
 	for _, f := range hopHeaders {
-		h.Del(f)
+		delete(h, f)
 	}
 }

@@ -725,7 +723,10 @@ func upgradeType(h http.Header) string {
 	if !httpguts.HeaderValuesContainsToken(h["Connection"], "Upgrade") {
 		return ""
 	}
-	return h.Get("Upgrade")
+	if v := h["Upgrade"]; len(v) > 0 {
+		return v[0]
+	}
+	return ""
 }

 func (p *ReverseProxy) handleUpgradeResponse(rw http.ResponseWriter, req *http.Request, res *http.Response) {
@@ -783,7 +784,7 @@ func (p *ReverseProxy) handleUpgradeResponse(rw http.ResponseWriter, req *http.R
 		return
 	}
 	errc := make(chan error, 1)
-	spc := switchProtocolCopier{user: conn, backend: backConn}
+	spc := switchProtocolCopier{user: conn, backend: backConn, bufferPool: p.BufferPool}
 	go spc.copyToBackend(errc)
 	go spc.copyFromBackend(errc)
 	<-errc
@@ -793,15 +794,32 @@ func (p *ReverseProxy) handleUpgradeResponse(rw http.ResponseWriter, req *http.R
 // forth have nice names in stacks.
 type switchProtocolCopier struct {
 	user, backend io.ReadWriter
+	bufferPool    BufferPool
 }

 func (c switchProtocolCopier) copyFromBackend(errc chan<- error) {
-	_, err := io.Copy(c.user, c.backend)
+	var buf []byte
+	if c.bufferPool != nil {
+		buf = c.bufferPool.Get()
+		defer c.bufferPool.Put(buf)
+	}
+	if len(buf) == 0 {
+		buf = make([]byte, 32*1024)
+	}
+	_, err := io.CopyBuffer(c.user, c.backend, buf)
 	errc <- err
 }

 func (c switchProtocolCopier) copyToBackend(errc chan<- error) {
-	_, err := io.Copy(c.backend, c.user)
+	var buf []byte
+	if c.bufferPool != nil {
+		buf = c.bufferPool.Get()
+		defer c.bufferPool.Put(buf)
+	}
+	if len(buf) == 0 {
+		buf = make([]byte, 32*1024)
+	}
+	_, err := io.CopyBuffer(c.backend, c.user, buf)
 	errc <- err
 }

@@ -837,3 +855,9 @@ func ishex(c byte) bool {
 	}
 	return false
 }
+
+//go:linkname putRequest net/http.putRequest
+func putRequest(r *http.Request)
+
+//go:linkname setRequestContext net/http.setRequestContext
+func setRequestContext(r *http.Request, ctx context.Context)
diff --git a/src/net/http/request.go b/src/net/http/request.go
index a45c9e3d18..f25879993b 100644
--- a/src/net/http/request.go
+++ b/src/net/http/request.go
@@ -357,12 +357,19 @@ func (r *Request) WithContext(ctx context.Context) *Request {
 	if ctx == nil {
 		panic("nil context")
 	}
-	r2 := new(Request)
+	r2 := newRequest()
 	*r2 = *r
 	r2.ctx = ctx
 	return r2
 }

+func setRequestContext(r *Request, ctx context.Context) {
+	if ctx == nil {
+		panic("nil context")
+	}
+	r.ctx = ctx
+}
+
 // Clone returns a deep copy of r with its context changed to ctx.
 // The provided ctx must be non-nil.
 //
@@ -373,7 +380,7 @@ func (r *Request) Clone(ctx context.Context) *Request {
 	if ctx == nil {
 		panic("nil context")
 	}
-	r2 := new(Request)
+	r2 := newRequest()
 	*r2 = *r
 	r2.ctx = ctx
 	r2.URL = cloneURL(r.URL)
@@ -1015,6 +1022,24 @@ func putTextprotoReader(r *textproto.Reader) {
 	textprotoReaderPool.Put(r)
 }

+var requestPool sync.Pool
+
+func newRequest() *Request {
+	if v := requestPool.Get(); v != nil {
+		return v.(*Request)
+	}
+	return new(Request)
+}
+
+func putRequest(r *Request) {
+	if r == nil {
+		return
+	}
+	putHeader(r.Header)
+	*r = Request{}
+	requestPool.Put(r)
+}
+
 // ReadRequest reads and parses an incoming request from b.
 //
 // ReadRequest is a low-level function and should only be used for
@@ -1035,7 +1060,7 @@ func readRequest(b *bufio.Reader) (req *Request, err error) {
 	tp := newTextprotoReader(b)
 	defer putTextprotoReader(tp)

-	req = new(Request)
+	req = newRequest()

 	// First line: GET /index.html HTTP/1.0
 	var s string
diff --git a/src/net/http/server.go b/src/net/http/server.go
index c3c3f91d9a..4843684d00 100644
--- a/src/net/http/server.go
+++ b/src/net/http/server.go
@@ -2004,10 +2004,12 @@ func (c *conn) serve(ctx context.Context) {
 			if w.requestBodyLimitHit || w.closedRequestBodyEarly() {
 				c.closeWriteAndWait()
 			}
+			putRequest(w.req)
 			return
 		}
 		c.setState(c.rwc, StateIdle, runHooks)
 		c.curReq.Store(nil)
+		putRequest(w.req)

 		if !w.conn.server.doKeepAlives() {
 			// We're in shutdown mode. We might've replied
@@ -2156,7 +2158,8 @@ func StripPrefix(prefix string, h Handler) Handler {
 		p := strings.TrimPrefix(r.URL.Path, prefix)
 		rp := strings.TrimPrefix(r.URL.RawPath, prefix)
 		if len(p) < len(r.URL.Path) && (r.URL.RawPath == "" || len(rp) < len(r.URL.RawPath)) {
-			r2 := new(Request)
+			r2 := newRequest()
+			defer putRequest(r2)
 			*r2 = *r
 			r2.URL = new(url.URL)
 			*r2.URL = *r.URL
@@ -2923,7 +2926,7 @@ func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) {

 	if req.URL != nil && strings.Contains(req.URL.RawQuery, ";") {
 		var allowQuerySemicolonsInUse atomic.Bool
-		req = req.WithContext(context.WithValue(req.Context(), silenceSemWarnContextKey, func() {
+		setRequestContext(req, context.WithValue(req.Context(), silenceSemWarnContextKey, func() {
 			allowQuerySemicolonsInUse.Store(true)
 		}))
 		defer func() {
diff --git a/src/net/textproto/reader.go b/src/net/textproto/reader.go
index fc2590b1cd..6deafeec33 100644
--- a/src/net/textproto/reader.go
+++ b/src/net/textproto/reader.go
@@ -14,6 +14,7 @@ import (
 	"strconv"
 	"strings"
 	"sync"
+	_ "unsafe"
 )

 // A Reader implements convenience methods for reading requests
@@ -482,6 +483,9 @@ func (r *Reader) ReadMIMEHeader() (MIMEHeader, error) {
 	return readMIMEHeader(r, math.MaxInt64, math.MaxInt64)
 }

+//go:linkname newHeader net/http.newHeader
+func newHeader(hint int) map[string][]string
+
 // readMIMEHeader is a version of ReadMIMEHeader which takes a limit on the header size.
 // It is called by the mime/multipart package.
 func readMIMEHeader(r *Reader, maxMemory, maxHeaders int64) (MIMEHeader, error) {
@@ -497,7 +501,7 @@ func readMIMEHeader(r *Reader, maxMemory, maxHeaders int64) (MIMEHeader, error)
 		strs = make([]string, hint)
 	}

-	m := make(MIMEHeader, hint)
+	var m MIMEHeader = newHeader(hint)

 	// Account for 400 bytes of overhead for the MIMEHeader, plus 200 bytes per entry.
 	// Benchmarking map creation as of go1.20, a one-entry MIMEHeader is 416 bytes and large
@@ -816,6 +820,33 @@ func initCommonHeader() {
 		"X-Forwarded-For",
 		"X-Imforwards",
 		"X-Powered-By",
+		"Cdn-Loop",
+		"Cf-Connecting-Ip",
+		"Cf-Ipcountry",
+		"Cf-Ray",
+		"Cf-Visitor",
+		"Dnt",
+		"Priority",
+		"Sec-Ch-Ua",
+		"Sec-Ch-Ua-Mobile",
+		"Sec-Ch-Ua-Platform",
+		"Sec-Fetch-Dest",
+		"Sec-Fetch-Mode",
+		"Sec-Fetch-Site",
+		"Sec-Fetch-User",
+		"Upgrade-Insecure-Requests",
+		"X-Forwarded-Proto",
+		"X-Real-Ip",
+		"Authorization",
+		"Content-Encoding",
+		"Strict-Transport-Security",
+		"Vary",
+		"X-Content-Type-Options",
+		"X-Frame-Options",
+		"X-Xss-Protection",
+		"Link",
+		"Origin",
+		"Referer",
 	} {
 		commonHeader[v] = v
 	}
--
2.40.1

